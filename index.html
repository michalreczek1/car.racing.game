<!DOCTYPE html>
<html lang="pl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Wyścig 3D - Omijanie przeszkód</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            font-family: Arial, sans-serif;
        }
        #info {
            position: absolute;
            top: 10px;
            left: 10px;
            color: white;
            background-color: rgba(0, 0, 0, 0.5);
            padding: 10px;
            border-radius: 5px;
            z-index: 100;
        }
        #gameOver {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: white;
            background-color: rgba(0, 0, 0, 0.7);
            padding: 20px;
            border-radius: 10px;
            text-align: center;
            display: none;
            z-index: 100;
        }
        button {
            padding: 10px 20px;
            font-size: 16px;
            margin-top: 15px;
            cursor: pointer;
            background-color: #4CAF50;
            color: white;
            border: none;
            border-radius: 5px;
        }
        button:hover {
            background-color: #45a049;
        }
        #instructions {
            position: absolute;
            bottom: 10px;
            left: 10px;
            color: white;
            background-color: rgba(0, 0, 0, 0.5);
            padding: 10px;
            border-radius: 5px;
            z-index: 100;
        }
    </style>
</head>
<body>
    <div id="info">
        <div>Dystans: <span id="distance">0</span> m</div>
        <div>Prędkość: <span id="speed">0</span> km/h</div>
        <div>Punkty: <span id="score">0</span></div>
    </div>
    <div id="gameOver">
        <h2>Koniec gry!</h2>
        <p id="gameOverMessage"></p>
        <div>Przebyty dystans: <span id="finalDistance">0</span> m</div>
        <button id="restartButton">Zagraj ponownie</button>
    </div>
    <div id="instructions">
        Sterowanie: Strzałki lewo/prawo do zmiany pasa
    </div>
    <div id="startScreen" style="position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); text-align: center; color: white; background-color: rgba(0, 0, 0, 0.7); padding: 20px; border-radius: 10px;">
        <h2>Wyścig 3D</h2>
        <p>Kliknij przycisk poniżej, aby rozpocząć grę</p>
        <button id="startButton">Rozpocznij grę</button>
    </div>
    
    <!-- Importowanie Three.js i wymaganych modułów -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/GLTFLoader.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/DRACOLoader.js"></script>
    <script>
        // Zmienne globalne
        let scene, camera, renderer;
        let car, road;
        let obstacles = [];
        let trees = [];
        let clouds = [];
        let frustum = new THREE.Frustum();
        let cameraMatrix = new THREE.Matrix4();
        let carPosition = 0;
        let moveSpeed = 0.15;
        let gameSpeed = 0.2;
        let currentSpeed = 60;
        let distance = 0;
        let score = 0;
        let isGameOver = false;
        let roadWidth = 15;
        let laneWidth = roadWidth / 3;
        let carWidth = 2;
        let carHeight = 1.5;
        let carLength = 4;
        let clock = new THREE.Clock();
        let elapsedTime = 0;
        let obstacleSpawnTime = 1.5;
        let timeSinceLastObstacle = 0;
        let difficultyModifier = 1;
        let isInitialized = false;
        let isGameStarted = false;
        let engineSound, crashSound;
        let playerName = '';
        let treeInstances = []; // Tablica na instancje drzew
        let cloudInstancesList = []; // Zmieniamy nazwę na cloudInstancesList
        let treeGeometry, treeMaterial; // Geometria i materiał dla drzew
        let cloudGeometry, cloudMaterial; // Geometria i materiał dla chmur
        // Systemy cząsteczek
        let exhaustParticlesSystem;

        // Parametry chmur
        let cloudParallaxFactor = 0.01; 
        let cloudSpawnInterval = 7.5;
        let timeSinceLastCloud = 0;

        // Inicjalizacja dźwięków
        function initSounds() {
            try {
                engineSound = new Audio();
                crashSound = new Audio();

                engineSound.src = 'engine.mp3';
                crashSound.src = 'crash.mp3';

                engineSound.loop = true;
                engineSound.volume = 0.5;
                crashSound.volume = 0.7;

                // Próba załadowania dźwięków
                engineSound.load();
                crashSound.load();

                console.log('Dźwięki zainicjalizowane');
            } catch (error) {
                console.error('Błąd podczas inicjalizacji dźwięków:', error);
            }
        }

        // Tworzenie instancji drzewa
        function createTreeInstance() {
            // Geometria pnia
            const trunkGeometry = new THREE.CylinderGeometry(0.5, 0.7, 3, 8);
            // Geometria korony
            const leavesGeometry = new THREE.ConeGeometry(2.5, 5, 8);
            
            // Materiały
            const trunkMaterial = new THREE.MeshStandardMaterial({ color: 0x8B4513 });
            const leavesMaterial = new THREE.MeshStandardMaterial({ color: 0x228B22 });
            
            return {
                trunkGeometry,
                leavesGeometry,
                trunkMaterial,
                leavesMaterial
            };
        }

        // Dodawanie drzew na poboczu z użyciem instanced geometry
        function addTrees() {
            // Tworzymy instancje drzewa
            const treeInstance = createTreeInstance();
            treeGeometry = treeInstance.trunkGeometry;
            treeMaterial = treeInstance.trunkMaterial;
            
            // Tworzymy instancje dla pni i koron
            const trunkInstances = new THREE.InstancedMesh(treeGeometry, treeMaterial, 100);
            const leavesInstances = new THREE.InstancedMesh(treeInstance.leavesGeometry, treeInstance.leavesMaterial, 100);
            
            const matrix = new THREE.Matrix4();
            let instanceCount = 0;
            
            for (let z = -1000; z < 1000; z += 40) {
                // Lewa strona
                matrix.setPosition(-roadWidth - 5 - Math.random() * 10, 0, z + Math.random() * 20);
                trunkInstances.setMatrixAt(instanceCount, matrix);
                matrix.setPosition(-roadWidth - 5 - Math.random() * 10, 5, z + Math.random() * 20);
                leavesInstances.setMatrixAt(instanceCount, matrix);
                
                // Prawa strona
                matrix.setPosition(roadWidth + 5 + Math.random() * 10, 0, z + Math.random() * 20);
                trunkInstances.setMatrixAt(instanceCount + 1, matrix);
                matrix.setPosition(roadWidth + 5 + Math.random() * 10, 5, z + Math.random() * 20);
                leavesInstances.setMatrixAt(instanceCount + 1, matrix);
                
                instanceCount += 2;
            }
            
            trunkInstances.count = instanceCount;
            leavesInstances.count = instanceCount;
            
            scene.add(trunkInstances);
            scene.add(leavesInstances);
            treeInstances.push(trunkInstances, leavesInstances);
        }

        // Tworzenie instancji chmury - naturalny kształt
        function createCloudInstance() {
            // Tworzymy teksturę chmury - bardziej naturalna
            const canvas = document.createElement('canvas');
            canvas.width = 300;  // Szersze dla lepszego kształtu
            canvas.height = 150; // Wyższe dla bardziej naturalnego wyglądu
            const ctx = canvas.getContext('2d');
            
            // Czyszczenie canvas
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // Rysujemy prostszy, bardziej naturalny kształt chmury
            ctx.beginPath();
            
            // Główny kształt - podstawa chmury
            ctx.moveTo(50, 100);
            ctx.bezierCurveTo(50, 130, 80, 130, 110, 120);
            ctx.bezierCurveTo(140, 130, 200, 130, 230, 110);
            ctx.bezierCurveTo(260, 130, 280, 110, 280, 80);
            ctx.bezierCurveTo(290, 50, 260, 30, 230, 40);
            ctx.bezierCurveTo(220, 20, 170, 20, 150, 30);
            ctx.bezierCurveTo(130, 10, 80, 20, 70, 40);
            ctx.bezierCurveTo(30, 30, 20, 70, 50, 100);
            
            // Wypełniamy chmurę na biało
            ctx.fillStyle = 'white';
            ctx.fill();
            
            // Dodajemy jasnoniebieski kontur
            ctx.strokeStyle = '#6ab7ff';
            ctx.lineWidth = 3;
            ctx.stroke();
            
            const texture = new THREE.CanvasTexture(canvas);
            
            // Materiał chmury
            const material = new THREE.MeshBasicMaterial({ 
                map: texture,
                transparent: true,
                side: THREE.DoubleSide
            });
            
            // Geometria
            const geometry = new THREE.PlaneGeometry(1, 1);
            
            return {
                geometry,
                material
            };
        }

        // Tworzenie chmur jako płaskich tekstur na niebie
        function createClouds() {
            console.log('Chmury jak naturalne obłoki...');
            
            // Czyścimy poprzednie chmury
            cloudInstancesList.forEach(cloud => {
                scene.remove(cloud);
            });
            cloudInstancesList = [];
            
            const cloudInstance = createCloudInstance();
            const cloudGeometry = cloudInstance.geometry;
            const cloudMaterial = cloudInstance.material;
            
            // Tworzymy chmury rozłożone na niebie
            for (let i = 0; i < 25; i++) {
                const cloud = new THREE.Mesh(cloudGeometry, cloudMaterial);
                
                // Pozycja
                cloud.position.x = (Math.random() - 0.5) * 800;
                cloud.position.y = 80 + Math.random() * 100;
                cloud.position.z = -200 + Math.random() * 1000;
                
                // Różne rozmiary chmur
                const scale = 30 + Math.random() * 120;
                cloud.scale.set(scale, scale / 2, 1);
                
                // Mniejszy, bardziej naturalny rozrzut obrotu
                cloud.rotation.z = (Math.random() - 0.5) * 0.5; // Mniej skręcone
                
                scene.add(cloud);
                cloudInstancesList.push(cloud);
            }
        }

        // Tworzenie nowej chmury
        function spawnNewCloud() {
            if (!scene) return;
            
            const cloudInstance = createCloudInstance();
            const cloud = new THREE.Mesh(cloudInstance.geometry, cloudInstance.material);
            
            // Pozycja
            cloud.position.x = (Math.random() - 0.5) * 800;
            cloud.position.y = 80 + Math.random() * 100;
            cloud.position.z = 800;
            
            // Różne rozmiary chmur
            const scale = 30 + Math.random() * 120;
            cloud.scale.set(scale, scale / 2, 1);
            
            // Mniejszy, bardziej naturalny rozrzut obrotu
            cloud.rotation.z = (Math.random() - 0.5) * 0.5; // Mniej skręcone
            
            scene.add(cloud);
            cloudInstancesList.push(cloud);
        }
        
        // Tworzenie drogi
        function createRoad() {
            const roadGeometry = new THREE.PlaneGeometry(roadWidth, 2000);
            const roadMaterial = new THREE.MeshStandardMaterial({ color: 0x333333 });
            
            road = new THREE.Mesh(roadGeometry, roadMaterial);
            road.rotation.x = -Math.PI / 2;
            road.position.y = -0.1;
            road.receiveShadow = true;
            scene.add(road);
            
            // Oznaczenia pasów
            for (let i = -1; i <= 1; i += 2) {
                const laneMarkerGeometry = new THREE.PlaneGeometry(0.3, 2000);
                const laneMarkerMaterial = new THREE.MeshStandardMaterial({ 
                    color: 0xFFFFFF,
                    side: THREE.DoubleSide
                });
                
                const laneMarker = new THREE.Mesh(laneMarkerGeometry, laneMarkerMaterial);
                laneMarker.rotation.x = -Math.PI / 2;
                laneMarker.position.set(i * laneWidth, -0.05, 0);
                scene.add(laneMarker);
            }
            
            // Środkowa linia przerywana
            for (let z = -1000; z < 1000; z += 10) {
                const centerMarkerGeometry = new THREE.PlaneGeometry(0.3, 5);
                const centerMarkerMaterial = new THREE.MeshStandardMaterial({ 
                    color: 0xFFFFFF,
                    side: THREE.DoubleSide
                });
                
                const centerMarker = new THREE.Mesh(centerMarkerGeometry, centerMarkerMaterial);
                centerMarker.rotation.x = -Math.PI / 2;
                centerMarker.position.set(0, -0.05, z);
                scene.add(centerMarker);
            }
            
            // Pobocze (pas zieleni)
            const leftSideGeometry = new THREE.PlaneGeometry(20, 2000);
            const rightSideGeometry = new THREE.PlaneGeometry(20, 2000);
            const grassMaterial = new THREE.MeshStandardMaterial({ 
                color: 0x2E8B57,
                side: THREE.DoubleSide
            });
            
            const leftSide = new THREE.Mesh(leftSideGeometry, grassMaterial);
            leftSide.rotation.x = -Math.PI / 2;
            leftSide.position.set(-roadWidth/2 - 10, -0.15, 0);
            scene.add(leftSide);
            
            const rightSide = new THREE.Mesh(rightSideGeometry, grassMaterial);
            rightSide.rotation.x = -Math.PI / 2;
            rightSide.position.set(roadWidth/2 + 10, -0.15, 0);
            scene.add(rightSide);
            
            // Dodanie drzew na poboczu
            addTrees();
        }
        
        // Tworzenie samochodu
        function createCar() {
            // Tworzymy grupę dla samochodu
            car = new THREE.Group();
            
            // Materiały
            const bodyMaterial = new THREE.MeshStandardMaterial({ 
                color: 0xff0000,
                metalness: 0.8,
                roughness: 0.2,
                envMapIntensity: 1
            });
            
            const windowMaterial = new THREE.MeshStandardMaterial({ 
                color: 0x87CEEB,
                metalness: 0.9,
                roughness: 0.1,
                transparent: true,
                opacity: 0.7
            });
            
            const wheelMaterial = new THREE.MeshStandardMaterial({ 
                color: 0x222222,
                metalness: 0.7,
                roughness: 0.3
            });
            
            const chromeMaterial = new THREE.MeshStandardMaterial({ 
                color: 0xffffff,
                metalness: 1.0,
                roughness: 0.1
            });
            
            const headlightMaterial = new THREE.MeshStandardMaterial({ 
                color: 0xffffff,
                emissive: 0xffffff,
                emissiveIntensity: 1.0
            });
            
            const exhaustMaterial = new THREE.MeshStandardMaterial({ 
                color: 0x333333,
                metalness: 0.9,
                roughness: 0.3
            });
            
            // Nadwozie główne
            const bodyGeometry = new THREE.BoxGeometry(carWidth, carHeight * 0.5, carLength);
            const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
            body.position.y = carHeight * 0.25;
            body.castShadow = true;
            car.add(body);
            
            // Przód samochodu
            const frontGeometry = new THREE.BoxGeometry(carWidth, carHeight * 0.3, carLength * 0.2);
            const front = new THREE.Mesh(frontGeometry, bodyMaterial);
            front.position.y = carHeight * 0.15;
            front.position.z = carLength * 0.4;
            front.castShadow = true;
            car.add(front);
            
            // Tyl samochodu
            const rearGeometry = new THREE.BoxGeometry(carWidth, carHeight * 0.4, carLength * 0.3);
            const rear = new THREE.Mesh(rearGeometry, bodyMaterial);
            rear.position.y = carHeight * 0.2;
            rear.position.z = -carLength * 0.35;
            rear.castShadow = true;
            car.add(rear);
            
            // Kabina
            const cabinGeometry = new THREE.BoxGeometry(carWidth * 0.9, carHeight * 0.4, carLength * 0.5);
            const cabin = new THREE.Mesh(cabinGeometry, windowMaterial);
            cabin.position.y = carHeight * 0.6;
            cabin.position.z = carLength * 0.05;
            cabin.castShadow = true;
            car.add(cabin);
            
            // Przednia szyba
            const windshieldGeometry = new THREE.BoxGeometry(carWidth * 0.9, carHeight * 0.2, carLength * 0.1);
            const windshield = new THREE.Mesh(windshieldGeometry, windowMaterial);
            windshield.position.y = carHeight * 0.5;
            windshield.position.z = carLength * 0.2;
            windshield.rotation.x = -Math.PI / 6;
            car.add(windshield);
            
            // Tylna szyba
            const rearWindowGeometry = new THREE.BoxGeometry(carWidth * 0.9, carHeight * 0.2, carLength * 0.1);
            const rearWindow = new THREE.Mesh(rearWindowGeometry, windowMaterial);
            rearWindow.position.y = carHeight * 0.5;
            rearWindow.position.z = -carLength * 0.2;
            rearWindow.rotation.x = Math.PI / 6;
            car.add(rearWindow);
            
            // Koła
            const wheelGeometry = new THREE.CylinderGeometry(0.3, 0.3, 0.2, 32);
            wheelGeometry.rotateX(Math.PI / 2);
            
            // Felgi
            const rimGeometry = new THREE.CylinderGeometry(0.2, 0.2, 0.21, 32);
            rimGeometry.rotateX(Math.PI / 2);
            
            // Przednie koła
            const frontLeftWheel = new THREE.Group();
            const frontLeftTire = new THREE.Mesh(wheelGeometry, wheelMaterial);
            const frontLeftRim = new THREE.Mesh(rimGeometry, chromeMaterial);
            frontLeftWheel.add(frontLeftTire);
            frontLeftWheel.add(frontLeftRim);
            frontLeftWheel.position.set(-carWidth/2, 0.3, carLength/3);
            frontLeftWheel.castShadow = true;
            car.add(frontLeftWheel);
            
            const frontRightWheel = new THREE.Group();
            const frontRightTire = new THREE.Mesh(wheelGeometry, wheelMaterial);
            const frontRightRim = new THREE.Mesh(rimGeometry, chromeMaterial);
            frontRightWheel.add(frontRightTire);
            frontRightWheel.add(frontRightRim);
            frontRightWheel.position.set(carWidth/2, 0.3, carLength/3);
            frontRightWheel.castShadow = true;
            car.add(frontRightWheel);
            
            // Tylne koła
            const rearLeftWheel = new THREE.Group();
            const rearLeftTire = new THREE.Mesh(wheelGeometry, wheelMaterial);
            const rearLeftRim = new THREE.Mesh(rimGeometry, chromeMaterial);
            rearLeftWheel.add(rearLeftTire);
            rearLeftWheel.add(rearLeftRim);
            rearLeftWheel.position.set(-carWidth/2, 0.3, -carLength/3);
            rearLeftWheel.castShadow = true;
            car.add(rearLeftWheel);
            
            const rearRightWheel = new THREE.Group();
            const rearRightTire = new THREE.Mesh(wheelGeometry, wheelMaterial);
            const rearRightRim = new THREE.Mesh(rimGeometry, chromeMaterial);
            rearRightWheel.add(rearRightTire);
            rearRightWheel.add(rearRightRim);
            rearRightWheel.position.set(carWidth/2, 0.3, -carLength/3);
            rearRightWheel.castShadow = true;
            car.add(rearRightWheel);
            
            // Reflektory
            const headlightGeometry = new THREE.SphereGeometry(0.2, 32, 32);
            
            const leftHeadlight = new THREE.Mesh(headlightGeometry, headlightMaterial);
            leftHeadlight.position.set(-carWidth/2, 0.3, carLength/2);
            car.add(leftHeadlight);
            
            const rightHeadlight = new THREE.Mesh(headlightGeometry, headlightMaterial);
            rightHeadlight.position.set(carWidth/2, 0.3, carLength/2);
            car.add(rightHeadlight);
            
            // Światła tylne
            const taillightGeometry = new THREE.SphereGeometry(0.15, 32, 32);
            const taillightMaterial = new THREE.MeshStandardMaterial({ 
                color: 0xff0000,
                emissive: 0xff0000,
                emissiveIntensity: 0.5
            });
            
            const leftTaillight = new THREE.Mesh(taillightGeometry, taillightMaterial);
            leftTaillight.position.set(-carWidth/2, 0.3, -carLength/2);
            car.add(leftTaillight);
            
            const rightTaillight = new THREE.Mesh(taillightGeometry, taillightMaterial);
            rightTaillight.position.set(carWidth/2, 0.3, -carLength/2);
            car.add(rightTaillight);
            
            // Dodajemy rurę wydechową
            const exhaustPipeGeometry = new THREE.CylinderGeometry(0.1, 0.1, 0.4, 8);
            exhaustPipeGeometry.rotateX(Math.PI / 2); // Obróć, aby cylinder był poziomo
            const exhaustPipe = new THREE.Mesh(exhaustPipeGeometry, exhaustMaterial);
            exhaustPipe.position.set(carWidth/4, 0.25, -carLength/2 - 0.1); // Umieść z tyłu samochodu
            car.add(exhaustPipe);
            
            // Dodajemy zakończenie rury wydechowej
            const exhaustTipGeometry = new THREE.CylinderGeometry(0.12, 0.1, 0.1, 8);
            exhaustTipGeometry.rotateX(Math.PI / 2);
            const exhaustTip = new THREE.Mesh(exhaustTipGeometry, chromeMaterial);
            exhaustTip.position.set(carWidth/4, 0.25, -carLength/2 - 0.25);
            car.add(exhaustTip);
            
            // Lusterka
            const mirrorGeometry = new THREE.BoxGeometry(0.1, 0.1, 0.2);
            
            const leftMirror = new THREE.Mesh(mirrorGeometry, chromeMaterial);
            leftMirror.position.set(-carWidth/2 - 0.1, carHeight * 0.5, carLength/3);
            car.add(leftMirror);
            
            const rightMirror = new THREE.Mesh(mirrorGeometry, chromeMaterial);
            rightMirror.position.set(carWidth/2 + 0.1, carHeight * 0.5, carLength/3);
            car.add(rightMirror);
            
            // Pozycja samochodu
            car.position.set(0, 0.75, 0);
            scene.add(car);
            isInitialized = true;
        }
        
        // Tworzenie przeszkody
        function createObstacle() {
            const lanes = [-1, 0, 1];
            const lane = lanes[Math.floor(Math.random() * lanes.length)];
            const obstacleType = Math.floor(Math.random() * 3);
            let obstacleGeometry, obstacleMaterial;

            if (obstacleType === 0) {
                obstacleGeometry = new THREE.BoxGeometry(
                    2 + Math.random() * 2,
                    1 + Math.random() * 2,
                    2 + Math.random() * 2
                );
                obstacleMaterial = new THREE.MeshStandardMaterial({ color: 0x808080 });
            } else if (obstacleType === 1) {
                obstacleGeometry = new THREE.CylinderGeometry(0.5, 0.5, 2, 8);
                obstacleMaterial = new THREE.MeshStandardMaterial({ color: 0xFFD700 });
            } else {
                obstacleGeometry = new THREE.BoxGeometry(1.5, 1, 2);
                obstacleMaterial = new THREE.MeshStandardMaterial({ color: 0x8B4513 });
            }

            const obstacle = new THREE.Mesh(obstacleGeometry, obstacleMaterial);
            obstacle.position.set(
                lane * laneWidth,
                obstacleGeometry.parameters.height / 2,
                1000
            );

            obstacle.castShadow = true;
            obstacle.receiveShadow = true;

            scene.add(obstacle);
            obstacles.push({
                mesh: obstacle,
                width: obstacleGeometry.parameters.width,
                height: obstacleGeometry.parameters.height,
                depth: obstacleGeometry.parameters.depth
            });
        }
        
        // Sprawdzanie kolizji
        function checkCollisions() {
            if (!car) return false;
            
            const carBoundingBox = new THREE.Box3().setFromObject(car);
            
            for (let i = 0; i < obstacles.length; i++) {
                const obstacleBoundingBox = new THREE.Box3().setFromObject(obstacles[i].mesh);
                
                if (carBoundingBox.intersectsBox(obstacleBoundingBox)) {
                    gameOver();
                    return true;
                }
            }
            
            return false;
        }
        
        // Funkcja sprawdzająca widoczność obiektu
        function isObjectVisible(object) {
            if (!object || !object.position) return false;
            
            // Tworzymy bounding sphere dla obiektu
            const boundingSphere = new THREE.Sphere();
            if (object instanceof THREE.Group) {
                // Dla grupy (chmury) używamy większego promienia
                boundingSphere.set(object.position, 10);
            } else {
                // Dla drzew używamy mniejszego promienia
                boundingSphere.set(object.position, 3);
            }
            
            // Sprawdzamy czy sphere przecina się z frustum
            return frustum.intersectsSphere(boundingSphere);
        }

        // Tworzenie systemu cząsteczek dla spalin z rury wydechowej
        function createExhaustParticles() {
            // Tekstura cząsteczki spalin
            const canvas = document.createElement('canvas');
            canvas.width = 32;
            canvas.height = 32;
            const ctx = canvas.getContext('2d');
            
            // Gradient dla cząsteczki spalin
            const gradient = ctx.createRadialGradient(16, 16, 0, 16, 16, 16);
            gradient.addColorStop(0, 'rgba(100, 100, 100, 0.7)'); // Mniejsza nieprzezroczystość
            gradient.addColorStop(0.3, 'rgba(70, 70, 70, 0.4)');  // Mniejsza nieprzezroczystość
            gradient.addColorStop(0.7, 'rgba(40, 40, 40, 0.2)');  // Mniejsza nieprzezroczystość
            gradient.addColorStop(1, 'rgba(20, 20, 20, 0)');
            
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, 32, 32);
            
            const texture = new THREE.CanvasTexture(canvas);
            
            // Geometria i materiał dla systemu cząsteczek
            const geometry = new THREE.BufferGeometry();
            const material = new THREE.PointsMaterial({
                size: 1.5, // Mniejszy rozmiar cząsteczek
                map: texture,
                transparent: true,
                opacity: 0.5, // Zmniejszona ogólna nieprzezroczystość
                depthWrite: false
            });
            
            const positions = new Float32Array(50 * 3); // Zmniejszone z 100 na 50 cząsteczek
            const velocities = new Float32Array(50 * 3);
            const lifetimes = new Float32Array(50);
            
            for (let i = 0; i < 50; i++) {
                positions[i * 3] = 0; 
                positions[i * 3 + 1] = 0;
                positions[i * 3 + 2] = 0;
                
                velocities[i * 3] = (Math.random() - 0.5) * 0.05; // Mniejsza prędkość pozioma
                velocities[i * 3 + 1] = Math.random() * 0.05;     // Mniejsza prędkość pionowa
                velocities[i * 3 + 2] = -Math.random() * 0.3 - 0.3; // Mniejsza prędkość w tył
                
                lifetimes[i] = Math.random() * 1.5; // Krótszy czas życia
            }
            
            geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            
            // Tworzenie systemu cząsteczek
            exhaustParticlesSystem = new THREE.Points(geometry, material);
            exhaustParticlesSystem.userData = {
                velocities: velocities,
                lifetimes: lifetimes,
                maxLifetimes: lifetimes.slice(),
                positions: positions
            };
            
            scene.add(exhaustParticlesSystem);
        }
        
        // Aktualizacja pozycji cząsteczek spalin - dopasowanie do rury wydechowej
        function updateExhaustParticles(delta) {
            if (!exhaustParticlesSystem || !car) return;
            
            const positions = exhaustParticlesSystem.geometry.attributes.position.array;
            const velocities = exhaustParticlesSystem.userData.velocities;
            const lifetimes = exhaustParticlesSystem.userData.lifetimes;
            const maxLifetimes = exhaustParticlesSystem.userData.maxLifetimes;
            
            // Pozyskanie pozycji rury wydechowej (dokładnie z tyłu samochodu)
            const exhaustPosition = new THREE.Vector3();
            exhaustPosition.set(
                car.position.x + carWidth/4, // Pozycja rury wydechowej po prawej stronie
                car.position.y + 0.25,       // Wysokość rury wydechowej
                car.position.z - carLength/2 - 0.3 // Tył samochodu, za końcówką rury
            );
            
            // Aktualizacja pozycji i czasu życia cząsteczek
            for (let i = 0; i < 50; i++) { // Aktualizacja dla mniejszej liczby cząsteczek
                lifetimes[i] -= delta;
                
                // Jeśli cząsteczka "umarła", zresetuj ją z 50% szansą (rzadsze tworzenie nowych)
                if (lifetimes[i] <= 0 && Math.random() < 0.5) {
                    positions[i * 3] = exhaustPosition.x + (Math.random() - 0.5) * 0.1;
                    positions[i * 3 + 1] = exhaustPosition.y + (Math.random() - 0.5) * 0.1;
                    positions[i * 3 + 2] = exhaustPosition.z + (Math.random() - 0.5) * 0.1;
                    
                    velocities[i * 3] = (Math.random() - 0.5) * 0.05;
                    velocities[i * 3 + 1] = Math.random() * 0.05;
                    velocities[i * 3 + 2] = -Math.random() * 0.3 - 0.3;
                    
                    lifetimes[i] = maxLifetimes[i];
                } else if (lifetimes[i] > 0) {
                    // Aktualizuj pozycję na podstawie prędkości
                    positions[i * 3] += velocities[i * 3];
                    positions[i * 3 + 1] += velocities[i * 3 + 1];
                    positions[i * 3 + 2] += velocities[i * 3 + 2];
                    
                    // Dodaj odrobinę grawitacji dla realistycznego opadania
                    velocities[i * 3 + 1] -= 0.01 * delta;
                }
            }
            
            // Zaktualizuj geometrię
            exhaustParticlesSystem.geometry.attributes.position.needsUpdate = true;
        }

        // Zaktualizowana pętla animacji dla chmur i cząsteczek
        function animate() {
            requestAnimationFrame(animate);

            if (!scene || !camera || !renderer || !car) { 
                return;
            }

            // Aktualizacja frustum
            cameraMatrix.multiplyMatrices(camera.projectionMatrix, camera.matrixWorldInverse);
            frustum.setFromProjectionMatrix(cameraMatrix);

            if (isGameStarted && !isGameOver && isInitialized) {
                const delta = clock.getDelta();
                elapsedTime += delta;

                gameSpeed = Math.min(gameSpeed + delta * 0.01, 1);
                if (distance > 0 && distance % 500 < 5) {
                    difficultyModifier += 0.05;
                }

                const targetX = carPosition * laneWidth;
                car.position.x += (targetX - car.position.x) * moveSpeed;

                const moveAmount = gameSpeed * difficultyModifier;
                currentSpeed = Math.floor(300 * gameSpeed);

                // Aktualizacja pozycji instancji drzew
                treeInstances.forEach(instance => {
                    const matrix = new THREE.Matrix4();
                    for (let i = 0; i < instance.count; i++) {
                        instance.getMatrixAt(i, matrix);
                        const position = new THREE.Vector3();
                        position.setFromMatrixPosition(matrix);
                        position.z -= moveAmount * 100 * delta;
                        
                        if (position.z < -50) {
                            position.z += 2000;
                        }
                        
                        matrix.setPosition(position);
                        instance.setMatrixAt(i, matrix);
                    }
                    instance.instanceMatrix.needsUpdate = true;
                });

                // Aktualizacja pozycji chmur - wolniejszy ruch dla efektu paralaksy
                const cloudSpeed = moveAmount * 20 * delta;
                for (let i = 0; i < cloudInstancesList.length; i++) {
                    const cloud = cloudInstancesList[i];
                    cloud.position.z -= cloudSpeed;
                    
                    // Jeśli chmura wyjdzie poza widok, przenosimy ją na początek
                    if (cloud.position.z < -100) {
                        cloud.position.z = 600;
                        cloud.position.x = (Math.random() - 0.5) * 300;
                        cloud.position.y = 100 + Math.random() * 50;
                    }
                }

                // Generowanie nowych chmur - z małym prawdopodobieństwem
                timeSinceLastCloud += delta;
                if (timeSinceLastCloud > cloudSpawnInterval && Math.random() < 0.1) {
                    spawnNewCloud();
                    timeSinceLastCloud = 0;
                }

                // Generowanie przeszkód
                timeSinceLastObstacle += delta;
                if (timeSinceLastObstacle > obstacleSpawnTime / difficultyModifier) {
                    createObstacle();
                    timeSinceLastObstacle = 0;
                }

                // Przemieszczanie przeszkód
                for (let i = obstacles.length - 1; i >= 0; i--) {
                    if (obstacles[i] && obstacles[i].mesh) {
                        obstacles[i].mesh.position.z -= moveAmount * 100 * delta;
                        if (obstacles[i].mesh.position.z < -50) {
                            scene.remove(obstacles[i].mesh);
                            obstacles.splice(i, 1);
                            score += 10;
                        }
                    } else {
                        console.warn('Próba dostępu do nieprawidłowej przeszkody, indeks:', i);
                        obstacles.splice(i, 1);
                    }
                }

                distance += moveAmount * delta * 10;
                document.getElementById('distance').textContent = Math.floor(distance);
                document.getElementById('speed').textContent = currentSpeed;
                document.getElementById('score').textContent = score;

                checkCollisions();

                // Aktualizacja tylko systemu cząsteczek spalin
                updateExhaustParticles(delta);
            }

            renderer.render(scene, camera);
        }
        
        // Koniec gry
        function gameOver() {
            isGameOver = true;

            if (engineSound) {
                try {
                    engineSound.pause();
                    engineSound.currentTime = 0;
                } catch (error) {
                    console.error('Błąd podczas zatrzymywania dźwięku silnika:', error);
                }
            }

            if (crashSound) {
                try {
                    crashSound.currentTime = 0;
                    crashSound.play();
                } catch (error) {
                    console.error('Błąd podczas odtwarzania dźwięku kolizji:', error);
                }
            }

            // Ustawienie komunikatu z imieniem i wynikiem
            const gameOverMessageElement = document.getElementById('gameOverMessage');
            if (gameOverMessageElement) {
                gameOverMessageElement.textContent = `Brawo ${playerName}, zdobyłeś ${score} punktów!`;
            }

            document.getElementById('finalDistance').textContent = Math.floor(distance);
            document.getElementById('gameOver').style.display = 'block';
        }
        
        // Restart gry
        function restartGame() {
            // Usunięcie wszystkich przeszkód
            for (let i = obstacles.length - 1; i >= 0; i--) {
                scene.remove(obstacles[i].mesh);
            }
            obstacles = [];
            
            // Usunięcie wszystkich chmur
            for (let i = clouds.length - 1; i >= 0; i--) {
                scene.remove(clouds[i]);
            }
            clouds = [];

            // Reset zmiennych
            carPosition = 0;
            gameSpeed = 0.2;
            currentSpeed = 60;
            distance = 0;
            score = 0;
            isGameOver = false;
            difficultyModifier = 1;
            
            // Reset pozycji samochodu
            car.position.x = 0;
            car.position.z = 0;
            
            // Aktualizacja interfejsu
            document.getElementById('distance').textContent = '0';
            document.getElementById('speed').textContent = '0';
            document.getElementById('score').textContent = '0';
            document.getElementById('gameOver').style.display = 'none';
            
            // Reset zegara
            clock = new THREE.Clock();
            timeSinceLastCloud = 0; // Reset timera chmur
            timeSinceLastObstacle = 0; // Reset timera przeszkód

            // Utworzenie początkowych chmur
            createClouds();

            // Ponowne uruchomienie dźwięku silnika
            if (engineSound) {
                try {
                    engineSound.play();
                } catch (error) {
                    console.error('Błąd podczas uruchamiania dźwięku silnika:', error);
                }
            }
        }
        
        // Start gry
        function startGame() {
            // Pytanie o imię gracza
            playerName = prompt("Podaj swoje imię:", "Gracz");
            if (!playerName) { // Jeśli gracz kliknie Anuluj lub zostawi puste
                playerName = "Gracz";
            }

            isGameStarted = true;
            document.getElementById('startScreen').style.display = 'none';
            
            // Uruchomienie dźwięku silnika
            if (engineSound) {
                try {
                    engineSound.play();
                } catch (error) {
                    console.error('Błąd podczas uruchamiania dźwięku silnika:', error);
                }
            }
        }
        
        // Obsługa klawiatury
        function onKeyDown(event) {
            if (isGameOver) return;

            switch (event.key) {
                case 'ArrowLeft':
                    if (carPosition < 1) carPosition++;
                    break;
                case 'ArrowRight':
                    if (carPosition > -1) carPosition--;
                    break;
                case 'ArrowUp':
                    gameSpeed = Math.min(gameSpeed + 0.05, 1);
                    break;
                case 'ArrowDown':
                    gameSpeed = Math.max(gameSpeed - 0.05, 0.1);
                    break;
            }
        }
        
        // Obsługa dotyku (mobilna)
        function onTouchStart(event) {
            if (isGameOver) return;

            // Zapobiegaj domyślnym akcjom, np. przewijaniu
            // event.preventDefault(); // Odkomentuj, jeśli powoduje problemy

            const touchX = event.touches[0].clientX;
            const screenWidth = window.innerWidth;

            if (touchX < screenWidth / 2) {
                // Dotknięcie lewej strony ekranu - ruch w lewo (jak ArrowLeft)
                if (carPosition < 1) carPosition++;
            } else {
                // Dotknięcie prawej strony ekranu - ruch w prawo (jak ArrowRight)
                if (carPosition > -1) carPosition--;
            }
        }
        
        // Dostosowanie do zmiany rozmiaru okna
        function onWindowResize() {
            const width = window.innerWidth;
            const height = window.innerHeight;
            
            camera.aspect = width / height;
            camera.updateProjectionMatrix();
            
            renderer.setSize(width, height);
        }

        // Inicjalizacja gry
        function initGame() {
            // Inicjalizacja sceny
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x87CEEB);
            
            // Inicjalizacja kamery - zmieniam wartość far, aby widzieć odległe chmury
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 10000);
            camera.position.set(0, 10, -15);
            camera.lookAt(0, 0, 30);
            
            // Inicjalizacja renderera
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            document.body.appendChild(renderer.domElement);
            
            // Światło - powrót do poprzednich ustawień
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
            scene.add(ambientLight);
            
            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight.position.set(100, 100, 50);
            directionalLight.castShadow = true;
            scene.add(directionalLight);

            const spotLight = new THREE.SpotLight(0xffffff, 1);
            spotLight.position.set(0, 5, -10);
            spotLight.castShadow = true;
            scene.add(spotLight);

            // Inicjalizacja dźwięków
            initSounds();
            
            // Tworzenie elementów gry
            createRoad();
            createCar();
            createClouds();
            
            // Dodajemy tylko system cząsteczek spalin
            createExhaustParticles();
            
            // Rozpoczęcie animacji
            animate();
        }

        // Event listenery
        window.addEventListener('resize', onWindowResize);
        document.addEventListener('keydown', onKeyDown);
        document.addEventListener('touchstart', onTouchStart); // Dodajemy listener dotyku
        document.getElementById('restartButton').addEventListener('click', restartGame);
        document.getElementById('startButton').addEventListener('click', startGame);

        // Rozpoczęcie gry
        initGame();
    </script>
</body>
</html>
